# Телеграм-бот на Python


Библиотека телеграм бота на Django


> БИБЛИОТЕКА НАХОДИТСЯ НА СТАДИИ РАЗРАБОТКИ. ИСПОЛЬЗОВАТЬ ЕЕ ПОКА НЕ РЕКОМЕНДУЕТСЯ.

Описание.
-----------
Библиотека BotMother построена на Django. В свою очередь, библиотека предназначена для создания разноуровневых ботов, начиная от инфомативных и заканчивая до онлайн-магазинов. Плюсы библиотеки заключаются в ее фунциональности и простоте понимания, посредством использования распространенных полезных функций. Далее будет подробно разобраны примеры применения функций BotMother. 

Requirements.
-----------
1.	Python 3 
2.	Django последней версии
3.	Ngrok – можете установить и почитать документацию по [ссылке](https://ngrok.com/download) 

Установка
-----------
 1.	Запустите команду:
 * http - `pip install git+https://github.com/mondaylabs/botmother.git@v0.3.4`
 * ssh  - `pip install git+ssh://git@github.com/mondaylabs/botmother.git@v0.3.4`

Библиотека установлена, идем дальше.

2.	Откройте файл `settings.py` (она находится в главной папке вашего проекта), добавьте в `INSTALLED_APPS` название библиотеки и вашего приложения:
```python
INSTALLED_APPS = [
    ...
    'botmother',
]
```

3.	Создайте своего бота помощью [BotFather]( @BotFather). Скопируйте токен созданного бота и задайте его в переменной `BOT_TOKEN` в том же `settings.py`: 
```python
BOT_TOKEN = '1619688226:AAFa1v1nPZXWG97wFdu4W**************'
```

4.	Далее, для того чтобы ваш бот правильно работал, вам следует создать модель `Chat` в `models.py`. 
```python
from botmother.models import AbstractChat

class Chat(AbstractChat):
    class Meta(AbstractChat.Meta):
        db_table = '<имя_вашего_приложения>_chats'
```
Еще пару очень важных моментов. `Chat` модель должна наследоваться от `AbstractChat` класса, та в свою очередь наследуется от `TelegramAPI` класса.
`AbstractChat`  уже имеет следующие переменные, такие как:  `chat_id, type, username, first_name, last_action, data, last_activity`.
Как видно выше, `AbstractChat` класс уже имеет достаточное количество переменных, которые могут быть полезны. Их не обязательно прописывать в своих моделях. 
Как показано выше, вам следует импортировать `AbstractChat` и прописать его в наследство созданной вами модели.

5.	Далее перейдите в `settings.py` и добавьте то, что показано ниже:
```python
BOTMOTHER_CHAT_MODEL = '<your_app_name>.Chat'
TESTING = ('test' == sys.argv[1]) if sys.argv else False
```

6.	Так же добавьте `ngrok` в `ALLOWED_HOSTS` следующим образом:
```python
ALLOWED_HOSTS = (
    ...
    'ngrok.io',
)
```

7.	Создайте файл `urls.py` в папке вашего приложения так, чтобы у вас получился путь `<имя_вашего_проекта >/<имя_вашего_приложения>/urls.py`, и добавьте функцию `dispatch`, как показано ниже:
```python
from botmother.webhook import webhook
from django.urls import path

def dispatch(router):
    router.command('/start', start),

urlpatterns = [
    path('', webhook(dispatch)),
],
```

8.	Перейдя в командную строку, пропишите команду `python manage.py migrate`.

9.	Запустите ngrok командой `ngrok http 8000`.
Важно указать, где находится файл `ngrok.exe` в командной строке. Затем, скопируйте появившуюся ссылку, показанную ниже:

    `Forwarding                    https://82691332ba1f.ngrok.io -> http://localhost:8000`

10.	Откройте еще одну командную строку, пропишите команду:

    `py manage.py setwebhook <скопированная_ссылка>` 

11.	Создайте файл `handlers.py` в папке приложения и напишите свою первую функцию `start`, ту, что добавили в функцию `dispatch` в `urls.py`:
```python
def start(chat, *args, **kwargs):
    chat.send_message('Hello, world!')
```
12.	Запустите бота командой `py manage.py runserver`

13.	Проверьте работоспособность своего бота!


Функции bot_router.py.
-----------
Еще один важный момент, который поможет лучше понять, как работает BotMother это функции в корневом файле bot_router.py (можете почитать по [ссылке](https://github.com/mondaylabs/botmother/blob/master/botmother/utils/bot_router.py)).
Все функции, в обязательном порядке, принимают аргумент function в виде обработчиков.
Сейчас я поочередно опишу каждую функцию:
* `сommand`   - Обязательный аргумент: `command,  function`. Нужна для обработки команд бота, таких как `/start`. Другие типы сообщений эта команда не принимает.
* `starts_with` - Обязательный аргумент: `prefix, function`. Направляет веб-перехватчик текстового типа, который начинается с заданного префикса.
* `text` - Обязательный аргумент: `text, function`. Отвечает только за текстовые команды. 
* `any` – Обязательный аргумент: `function`. Отвечает на любые типы данных.
* `callback` – Обязательный аргумент: `prefix, function`. Нужна при создании `inline` кнопок. Эта функция отправляет `callback` для дальнейшей обработки и ответа пользователю.
* `location` – Обязательный аргумент: `function`. Обрабатывает местоположение.
* `contact` – Обязательный аргумент: `function`. Обрабатывает контакт.
* `on_checkout_query` – Обязательный аргумент: `function`. Полезная функция при написании бота для онлайн-магазина. Данная функция может служить направляющей для дальнейшей оплаты или каких-либо других действий.
* `new_photo` – Обязательный аргумент: `function`. Перенапрявляет в функцию и при добавлении группового фото.

Все функции принимают необязательные аргументы, как: 
* `last_action` - самый полезное свойство, которое поможет прописать поочередность выполнения обработчиков.
* `chat_type` - private, group, supergroup, channel`. Если вы пишите чат-бота, то он будет работать в личной переписке.С другими работает аналогично.
* `edited` - сообщит боту изменено ли клиентом сообщение.
* `extra`  - можно прописать специфические данные, которые потом можно передать в хендлеры.



Инструкция по handlers.py и models.py. 
Описание самых важных функций.
-----------
Хендлеры – это функция, которая вызывается какой-либо программной системой в ответ на наступление какого-либо события. Их еще называют обработчиками. Следственно, можно понять, что они и будут выполнять всю работу вашего бота. Но, что бы они начали работать, нужно ознакомиться с функциями `BotMother`, которые помогут эти обработчики правильно прописать и связать.
 
При написании хендлеров, не стоит забывать о обязательных атрибутах, без которых ваша функция может не работать:

* `message` – обязательный атрибут, нужен, например для сохранения экземпляра модели `Message`.
* `chat` – самый главный атрибут, нужен для взаимодействия с клиентом. Нужен для сохранения экземпляра модели `Chat`. 
* `redirect` –  перенаправит на другую функцию после выполнения предыдущей. Обязательно пропишите ее в качестве аргумента в вашей функции. Далее укажите в `redirect` в качестве аргумента функцию, на которую вы хотите перейти.
* `location`  - нужен для обработки локации, отправленной клиентом.
* `phone` -  нужен для обработки контакта.
* `callback_data` – обязательный атрибут при inline-кнопках. После нажатия, бот должен получить запрос на обработку данных и выполнения
соответствующей функции. Этот запрос должен содержать callback_data. Он может быть невиден клиенту, но обязателен к внесению.
* `pre_checkout_query` – полезный атрибут для online-магазинов. Выполнит указанные действия, прописанные в этом атрибуте.
* `extra` – полезный атрибут при разграничении схожих функций.

Пропишите необходимые для работы атрибуты и `*args, **kwargs` в конце:
```python
def start(chat, *args, **kwargs):
    chat.send_message('Hello, world')
```
  
Рассмотрим модели `BotMother`:
1.	`class AbstractChat(Model, TelegramAPI)` – как было указано выше, ваш `class Chat` наследуется от `AbstractChat`. В свою очередь, `AbstractChat` наследуется от `TelegramAPI`. 
`AbstractChat` уже имеет следующие переменные: `chat_id, type, username, first_name, last_action, last_activity`. 

    И свойство `last_data`, которое временно присвоит значение какой либо переменной. 
    Для полного понимания, разберем пример. Допустим, вы создаете бота-опросника, бот задает 4-5 или больше вопросов, клиент, не ответив на все вопросы, закрывает бота. А что с данными? Естественно они сохранятся в базе данных, занимая нужную вам память. Так вот, во избежание этого BotMother использует `last_data`. Это свойство тоже использует вашу базу данных, но данные будут полностью внесены только после завершения всех прописанных вами действий. Оно вам поможет временно сохранить данные и избежать нагрузки. Сначала это может показаться незначительным. Но при создании больших проектов, разница будет ощутима.

    От `TelegramAPI` наша модель наследует следующие функции: 
* `send` – отправит данные в любом виде
* `send_message` – самая нужная и распространенная функция. С ней вы будете работать постоянно. Она будет отправлять данные только в текстовом виде. 
Также, она принимает в качестве аргумента `reply_markup`, что говорит о возможности отправки клавиатуры:
```python
chat.send_message('Choose the language: ', reply_markup=keyboard_name())
```
* `send_location, send_photo` – соответственно отправляет пользователю местоположение или фото. 
* `send_answer_pre_checkout_query` – Важная функция для онлайн-магазина. Проверяет правильность оплаты за продукт и отправляет сообщение, или же запускает какую-либо функцию после выполнения функции оплаты. 
* `send_invoice` – отправляет «чек» или опять же запускает вашу функцию, уведомляющую клиента о успешном снятии денег.
2.	А вот `class Message` не наследуется от `AbstractChat`, и имеет свои переменные: `id, date, chat, text, type`.


Рекомендации.
-----------
В этой части будут даны советы по успешному и правильному использованию библиотеки, грамотному использованию функций и построению иерархии бота:

1.	Начнем самого малого. Для дальнейшей гибкости вашего бота, следует прописать свою  `Chat` модель в `models.py`.

`models.py` библиотеки `BotMother` имеет `class AbstractChat`. Абстрактный метод – это метод, который не имеет своей реализации в базовом классе, и он должен быть реализован в классе-наследнике.
Поэтому вам в обязательном порядке нужно создать свою модель. Таким образом, вы можете добавить необходимые вам переменные. Обязательно пропишите в модели аргумент AbstractChat. Этим вы унаследуете уже существующие переменные:
```python
class Chat(AbstractChat):
    class Meta(AbstractChat.Meta):
        db_table = '<имя_вашего_приложения>_chats'
```
После написания модели, обязательно укажите это в `settings.py`:
```python
...
BOTMOTHER_CHAT_MODEL = '< имя_вашего_приложения>.Chat'
```
2.	Продолжая тему создания клавиатуры, хочется добавить, что необходимо, в первую очередь, эту клавиатуру создать. Сейчас будет пошагово разобрано, как это нужно реализовать:
* Создаем файл keyboards.py в папке приложения. 
* Создаем функцию, которая не принимает никаких аргументов. 
* Далее выполняем показанные ниже действия:
```python
def keyboard_name():
    return {
        'keyboard': [
            [{'text': '<your_text>'}],
            [{'text': '<your_text>'}]
        ],
    }
```
Клавиатура может принимать аргумент `resize_keyboard`, что сделает вашу клавиатуру красивее и стильнее. 

Также, можно скрыть клавиатуру после одного касания добавлением аргумента `one_time_keyboard`. Но не следует прописывать этот аргумент, в случаях, когда одна клавиатура заменяется другой.
```python
def func_name():
    return {
        'keyboard': [
            [{'text': 'RU'}],
            [{'text': 'US'}]
        ],
        'resize_keyboard': True,
        'one_time_keyboard': True,
    }
```

3. В `urls.py`, в обязательном порядке, первой должна быть ссылка на `/start` функцию, ибо работа любого бота начинается с этой команды. 
4. Для контроля последовательности выполнения функций, следует так же прописать в ссылках `urls.py` атрибут `last_action`. В ней может быть как 1 переменная, так и несколько, внесенных в свою очередь в список:
```python
router.command('/<your_command>', <func4>, last_action=[<func1>, <func2>, <func3>, <func4>])
```
Это может предотвратить случаи неверной последовательности запуска обработчиков.

5.	Немаловажный момент это сохранение поэтапности функций. Если вы пишете, например, бота-опросника, то верным решением будет сначала прописывать сам вопрос, а затем, в следующей функции, его обрабатывать  и продолжить по цепочке. Например:
```python
def start(chat, *args, **kwargs):
    chat.send_message(‘What is your name?’)
    
def ask_name(chat, *args, **kwargs ):
    name = message.text
    #ловите запрос от первой функции и обрабатываете
    chat.send_message(f‘Ok, {name}. How old are you?’)
    
def ask_age(chat, *args, **kwargs ):
    age = message.text
    #ловите запрос от второй функции и обрабатываете
    chat.send_message(f‘Oh, {name}. Welldone! You are already {age} years old!’)
```
